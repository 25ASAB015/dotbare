#!/usr/bin/env bash
#
# untrack selected files
#
# @params
# Globals
#   ${mydir}: current dir of the script
#   ${update_index}: use update index operation to temp untrack files
#   ${re_track}: retrack selected files
#   ${confirm}: use confirm status
#   ${selected_files}: user selected_files for operation
# Arguments
#   -h: display help message and exit
#   -s: temporarily untrack files
#   -S: resume track of temp untracked files

set -e
set -f

mydir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source "${mydir}"/../helper/set_variable.sh
source "${mydir}"/../helper/git_query.sh
source "${mydir}"/../helper/get_confirmation.sh

function usage() {
  echo -e "Usage: dotbare funtrack [-h] [-s] [-S] ...\n"
  echo -e "Untrack selected files from git\n"
  echo -e "Note: by default, the untrack will remove the file from index while"
  echo -e "keeping the file in your current system (git rm --cached filename)"
  echo -e "however, when your other computer pull down the changes, the file will be removed"
  echo -e "make sure to run dotbare fbackup before pulling down the changes, alternativly"
  echo -e "use the -s flag (git update-index --assume-unchanged [path])\n"
  echo -e "optional arguments:"
  echo -e "  -h\tshow this help message and exit"
  echo -e "  -s\ttemporarily ignore changes of selected files"
  echo -e "    \tuse -S flag to resume tracking changes of selected_files"
  echo -e "  -S\tresume tracking changes of selected files"
}

update_index=""
re_track=""

while getopts ":hsS" opt
do
  case "$opt" in
    s)
      update_index="true"
      ;;
    S)
      re_track="true"
      ;;
    h)
      usage
      exit 0
      ;;
    *)
      echo "Invalid option: ${OPTARG}" >&2
      usage
      exit 1
      ;;
  esac
done

selected_files=$(get_git_file "select files to untrack" | tr "\n" " ")
[[ -z "${selected_files}" ]] && exit 1


if [[ -n "${update_index}" ]]; then
  echo "(dryrun) dotbare update-index --assume-unchanged ${selected_files}"
  confirm=$(get_confirmation "Files will be temporarily stop being tracked for changes, continue?")
  [[ "${confirm}" != 'y' ]] && exit 1
  # shellcheck disable=SC2086
  /usr/bin/git --git-dir="${DOTBARE_DIR}" --work-tree="${DOTBARE_TREE}" update-index --assume-unchanged ${selected_files}
  echo -e " "
  echo "Selected files are temporarily untracked by git, use -S to continue tracking changes."
  echo "dotbare funtrack -s is not the recommanded way to untrack files, although it won't delete"
  echo "the files on other machines, please refer to git update-index official"
  echo "documentation for more information"
elif [[ -n "${re_track}" ]]; then
  echo "(dryrun) dotbare update-index --no-assume-unchanged ${selected_files}"
  confirm=$(get_confirmation "Files will resume being tracked by git, continue?")
  [[ "${confirm}" != 'y' ]] && exit 1
  # shellcheck disable=SC2086
  /usr/bin/git --git-dir="${DOTBARE_DIR}" --work-tree="${DOTBARE_TREE}" update-index --no-assume-unchanged ${selected_files}
  echo " "
  echo "Selected files are being resumed for track by git."
  echo "dotbare funtrack -s not the recommanded way to untrack files, although it won't delete"
  echo "the files on other machines, please refer to git update-index official"
  echo "documentation for more information"
else
  echo "(dryrun) dotbare rm --cached ${selected_files}"
  confirm=$(get_confirmation "Untrack the selected files?")
  [[ "${confirm}" != 'y' ]] && exit 1 
  # shellcheck disable=SC2086
  /usr/bin/git --git-dir="${DOTBARE_DIR}" --work-tree="${DOTBARE_TREE}" rm --cached ${selected_files}
  echo -e " "
  echo "Selected files are being untracked by git, make sure to run dotbare fbackup"
  echo "on your other systems. When other system pull down this change, selected files"
  echo "will be removed, this is the default behavior of git rm --cached, more information"
  echo "refer to dotbare funtrack -h or README"
fi
